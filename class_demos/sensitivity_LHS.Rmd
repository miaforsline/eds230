---
title: "sensitivity_LHS"
author: "Mia Forsline"
date: '2022-04-19'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(sensitivity)
library(tidyverse)
library(pse)
library(purrr)
```


```{r LHS}
# for formal sensitivity analysis it is useful to describe output in
# several summary statistics - how about mean, max and min yield
source("../R/compute_almond_yield.R")


# Lets consider 3 of the parameters....
factors = c("Tmincoeff1", "Tmincoeff2", "Pcoeff2")

# Decide How many parameter sets to generate
nsets=100

# choose distributions for parameters - this would come from
# what you know about the likely range of variation
#create a vector of function names 
#for each parameter, we tell the LHC what the distribution looks like - we're saying Tmin1 and Tmin2 come from normal distributions while Pcoeff comes from a uniform distribution 
q = c("qnorm", "qnorm", "qunif")
q.arg = list(list(mean=-0.015,sd=0.005), #normal distribution for Tmincoeff1
             list(mean=-0.0046, sd=0.001), #normal distribution for Tmincoeff2
             list(min=0.00429, max=0.00431)) #uniform distribution for Pcoeff2 
#mean and SD selected based on what we know about the parameters 

# generate samples from LHS
sens_almond = LHS(NULL,factors,nsets,q,q.arg) 
sens_pars = get.data(sens_almond) #we want to know what parameters we want to run 
head(sens_pars) #we can look at all the parameter values we want to run - we will have 100 parameter sets 
```

# Run model for parameter sets


* We then *tell* the results of the model to our *LHS* object that we generated when we generated parameter sets 

* To *tell* results must be a data.frame or matrix

* Decide what outputs are useful (you may need to summarize if your model
produces many outputs (e.g time series of streamflow))



```{r almondsens}
# read in the input data
SB=read.table("../data/clim.txt")
clim= SB

# lets now run our model for all of the parameters generated by LHS
# pmap is useful here - it is a map function that uses the actual names of input parameters

yields = sens_pars %>% pmap(compute_almond_yield,clim=clim)

# notice that what pmap returns is a list (has max, mean, min yield for each parameter set)
head(yields)

# turn results in to a dataframe for easy display/analysis
yieldsd = yields %>% map_dfr(`[`,c("maxyield","minyield","meanyield"))

# to take advantage of LHS/pse functions for 
# plotting interesting information we can send results back - 
# results need to be in a matrix
# each column is a different parameter set - we can use transpose (t)
# and as.matrix to get there

# tell is what links output to original LHS object

sens_almond = pse::tell(sens_almond, t(as.matrix(yieldsd)),
                        res.names=c("maxyield","minyield","meanyield"))
#tell(): send the model output to LHS object 
#yieldsd must be a matrix 
```


#  Plotting 

Plot relationship between parameter and output
to understand how uncertainty in parameter impacts the output to determine over what ranges of the parameter uncertainty is most important (biggest effect)


Use a box plot (of output)
to graphically show the impact of uncertainty on output of interest


```{r senplot}
# now we use built in LHS functions to analyze parameter sensitivity
#note sens_almond is a LHS object, so we can use the plotscatter() function 
pse::plotscatter(sens_almond, col="blue", cex=5)
#maxyield has a strong relationship w/Pcoeff2
#maxyield is related to Tmincoeff2 
#meanyield has a similar relationship to all 3 parameters 


# we can also plot results in interesting ways
# turn sens_almond into a data frame - easier access to R plotting functions

ggplot(yieldsd, aes(minyield, maxyield))+geom_point()+labs(y="Max Yield (as anomoly)", "Min Yield (as anomoly")


# add uncertainty bounds on our estimates
tmp = yieldsd %>% gather(value="value", key="yield")
ggplot(tmp, aes(yield, value, col=yield))+geom_boxplot()+
  labs(y="Yield (as anomoly)")
#graph yields for all parameter values 
#the scale/difference between max/mean/min yield is so large that we can't see variation between the 3 parameteres 

# note that you don't see the ranges because of the scale (min yield anomoly much smaller than max) - here's a more informative way to graph
ggplot(tmp, aes(yield, value, col=yield))+
  geom_boxplot()+labs(y="Yield (as anomoly)")+
  facet_wrap(~yield, scales="free" )
#now we can see the variation between the 3 parameters 

#1) scatter plot is essential
#2) box plot is essential to see variation 
```

# Quantifying Sensitivity


# PSE:TELL object  has partial rank correlation coefficients

```{r quantifying}
# prcc's automatically generated and easy to plot
pse::plotprcc(sens_almond)

# PRCC for all 3 output metrix
sens_almond$res.names
sens_almond$prcc

# correlation coefficient
# compare PRCC with first correlation coefficient
# recall
head(yieldsd)
sens_almond$prcc[1] #slightly larger effect size of Tmin coefs once we account for Pcoeff2 

# we can still use our sens_pars data frame - rows of parameters will be
# match rows in the output from our use of pmap to run the model for all 
# parameters
cor(yieldsd$maxyield, sens_pars$Tmincoeff1, method="spearman")
cor(yieldsd$maxyield, sens_pars$Tmincoeff2, method="spearman")
cor(yieldsd$maxyield, sens_pars$Pcoeff2, method = "spearman")
```

# Sobol 
```{r}
source(here::here("R", "Catm.R"))
```


```{r}
# names of our parameters
factors = c("k_o","k_d", "v","height")
# type of distributions they arise from
q = c("qnorm", "qnorm", "qnorm","qunif")
# parameters for those distributions
q.arg = list(list(mean=0.1,sd=0.1*0.1), list(mean=0.7, sd=0.7*0.1), list(mean=200, sd=10), 
             list(min=5, max=15))

nsets=200
sens_Catm = LHS(NULL,factors,nsets,q,q.arg, nboot=500)
# save parameter values
sens.pars = get.data(sens_Catm)

head(sens.pars)
```
```{r}
ggplot(sens.pars, aes(k_o))+geom_density()
ggplot(sens.pars, aes(x=k_o, y=k_d))+geom_density_2d()
```

```{r}
sens_res = Catm(v=sens.pars$v, height=sens.pars$height, k_o=sens.pars$k_o, k_d=sens.pars$k_d)

sens_Catm = tell(sens_Catm, sens_res, res.names="ga")


# note it can take standard R plotting parameters
plotscatter(sens_Catm, col="darkgreen", cex=5, ylab="Atm Cond (mm/s)")
```

```{r}
# we can also plot partial correlation coefficients
plotprcc(sens_Catm)
```

```{r}
plotecdf(sens_Catm, col="red", lwd=5, xlab="Atm Cond (mm/s)")
```

```{r}
np=1000
k_o = rnorm(mean=0.1,sd=0.1*0.1, n=np)
k_d = rnorm(mean=0.7, sd=0.7*0.1, n=np)
v = rnorm(mean=200, sd=10, n=np)
height = runif(min=5, max=15, n=np)


X1 = cbind.data.frame(k_o, k_d, v, height=height)

# repeat sampling
k_o = rnorm(mean=0.1,sd=0.1*0.1, n=np)
k_d = rnorm(mean=0.7, sd=0.7*0.1, n=np)
v = rnorm(mean=200, sd=10, n=np)
height = runif(min=5, max=15, n=np)

X2 = cbind.data.frame(k_o, k_d, v, height=height)

# there are different versions of sobol functions that have different approaches for estimating parameters and indices, we use an approach implemented by jansen 

sens_Catm_Sobol = sobolSalt(model = NULL, X1, X2, nboot = 100)


# Take a look at the Sobol generated sensitivity object
# your parameters sets for sensitivity analysis are in X

# run model for all parameter sets
# make sure you give the parameters names

parms = as.data.frame(sens_Catm_Sobol$X)
colnames(parms)= colnames(X1)
res = pmap_dbl(parms, Catm)


sens_Catm_Sobol = sensitivity::tell(sens_Catm_Sobol,res, res.names="ga")

# main effect:  partitions variance (main effect without co-variance) - sums approximately to one
sens_Catm_Sobol$S
```

```{r}
# useful to add names
row.names(sens_Catm_Sobol$S) = colnames(parms)
sens_Catm_Sobol$S
```

```{r}
# total effect - accounts for parameter interactions
row.names(sens_Catm_Sobol$T) = colnames(parms)
sens_Catm_Sobol$T
```

```{r}
# Both the main effect and total effect can tell us something about how the parameter influences results
print(sens_Catm_Sobol)
```

```{r}
# compare with LHS and PRCC
sens_Catm$prcc
```

```{r}
sens_Catm_Sobol$S
#partitions the variance based on the parameters - most of the distribution is due to height 
```

```{r}
sens_Catm_Sobol$T
```

```{r}
# make a data frame for plotting
both = cbind.data.frame(parms, gs=sens_Catm_Sobol$y)

# look at response of conductance to the two most important variables
ggplot(both, aes(v,gs, col=height))+geom_point()+labs(y="Conductance (mm/s)", x="Windspeed")
```



